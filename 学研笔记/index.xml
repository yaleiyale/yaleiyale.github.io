<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>学研笔记 on 时砂凝几页</title><link>http://lestua.eu.org/%E5%AD%A6%E7%A0%94%E7%AC%94%E8%AE%B0/</link><description>Recent content in 学研笔记 on 时砂凝几页</description><generator>Hugo -- gohugo.io</generator><language>zh</language><copyright> 2021-{year} yaleiyale</copyright><lastBuildDate>Fri, 14 Oct 2022 21:36:08 +0800</lastBuildDate><atom:link href="http://lestua.eu.org/%E5%AD%A6%E7%A0%94%E7%AC%94%E8%AE%B0/index.xml" rel="self" type="application/rss+xml"/><item><title>二叉树的遍历</title><link>http://lestua.eu.org/notes/2022/10/14/213638/</link><pubDate>Fri, 14 Oct 2022 21:36:08 +0800</pubDate><guid>http://lestua.eu.org/notes/2022/10/14/213638/</guid><description>先序遍历 先序遍历（PreOrder）的操作过程如下。 若二叉树为空，则什么也不做;否则， 访问根结点; 先序遍历左子树; 先序遍历右子树。 void PreOrder(BiTree T) { if</description></item><item><title>二叉树的存储结构</title><link>http://lestua.eu.org/notes/2022/10/10/084357/</link><pubDate>Mon, 10 Oct 2022 08:43:53 +0800</pubDate><guid>http://lestua.eu.org/notes/2022/10/10/084357/</guid><description>顺序存储 struct TreeNode { int value; bool isEmpty; }; // 定义一个长度为MAXSIZE的数组t,按照从上至下、从左至右的顺序依次存储完全二叉树中的各个结点 TreeNode t[MAXSIZE]; 初始化时所有结</description></item><item><title>二叉树的性质</title><link>http://lestua.eu.org/notes/2022/10/08/223628/</link><pubDate>Sat, 08 Oct 2022 22:41:53 +0800</pubDate><guid>http://lestua.eu.org/notes/2022/10/08/223628/</guid><description>设非空二叉树中度为0、1和2的结点个数分别为$n_0$、$n_1$和$n_2$,则$n_0$=$n_2$+1 (叶子结点比二分支结点多一个)1</description></item><item><title>二叉树的定义与基本术语</title><link>http://lestua.eu.org/notes/2022/10/08/223623/</link><pubDate>Sat, 08 Oct 2022 22:15:07 +0800</pubDate><guid>http://lestua.eu.org/notes/2022/10/08/223623/</guid><description>基础概念 二叉树是n(n≥0)个结点的有限集合： 或者为空二叉树，即n=0。 或者由一个根结点和两个互不相交的被称为根的左子树和右子树组成。左子树</description></item><item><title>树的性质</title><link>http://lestua.eu.org/notes/2022/10/08/223637/</link><pubDate>Sat, 08 Oct 2022 21:30:23 +0800</pubDate><guid>http://lestua.eu.org/notes/2022/10/08/223637/</guid><description>总结点数 = 总度数 + 11 树的度 VS m叉树 树的度：各结点的度的最大值 m叉树：每个结点最多只能有m个孩子的树 度为m的树 m叉树 任意结点的度≤m(最多m个</description></item><item><title>树的定义与基本术语</title><link>http://lestua.eu.org/notes/2022/10/08/223632/</link><pubDate>Sat, 08 Oct 2022 21:25:10 +0800</pubDate><guid>http://lestua.eu.org/notes/2022/10/08/223632/</guid><description>概念 ![[树与二叉树 2022-10-06 14.36.30.excalidraw]] 树是n(n≥0)个结点的有限集合，n=0时，称为空树，这是一种特殊情况。非空树的特性： 有且仅有一个根结点 没有后继的结</description></item><item><title>KMP算法</title><link>http://lestua.eu.org/notes/2022/10/03/223611/</link><pubDate>Mon, 03 Oct 2022 17:31:07 +0800</pubDate><guid>http://lestua.eu.org/notes/2022/10/03/223611/</guid><description>一些概念补充 前缀：除最后一个字符外，字符串的所有头部子串； 后缀：除第一个字符外，字符串的所有尾部子串； 部分匹配值：字符串的前缀与后缀的最长相</description></item><item><title>串的基本概念与实现</title><link>http://lestua.eu.org/notes/2022/10/03/223559/</link><pubDate>Mon, 03 Oct 2022 17:11:35 +0800</pubDate><guid>http://lestua.eu.org/notes/2022/10/03/223559/</guid><description>术语定义 串：即字符串(String)，是由零个或多个字符组成的有限序列。 子串：串中任意个连续的字符组成的子序列。 主串：包含子串的串。 字符在主</description></item><item><title>朴素模式匹配算法</title><link>http://lestua.eu.org/notes/2022/10/03/223603/</link><pubDate>Mon, 03 Oct 2022 16:21:07 +0800</pubDate><guid>http://lestua.eu.org/notes/2022/10/03/223603/</guid><description>定义 主串：匹配范围 模式串：匹配方向 字符串模式匹配：在主串中找到与模式串相同的子串，并返回其所在位置。 主串长度为n,模式串长度为m。朴素模式匹</description></item><item><title>字符串模式匹配</title><link>http://lestua.eu.org/notes/2022/10/03/223607/</link><pubDate>Mon, 03 Oct 2022 16:16:56 +0800</pubDate><guid>http://lestua.eu.org/notes/2022/10/03/223607/</guid><description>[[朴素模式匹配算法]] [[KMP算法]]</description></item><item><title>串</title><link>http://lestua.eu.org/notes/2022/08/29/223556/</link><pubDate>Wed, 03 Aug 2022 21:45:00 +0800</pubDate><guid>http://lestua.eu.org/notes/2022/08/29/223556/</guid><description>[[串的基本概念与实现]] [[字符串模式匹配]]</description></item><item><title>树与二叉树</title><link>http://lestua.eu.org/notes/2022/08/29/223643/</link><pubDate>Wed, 03 Aug 2022 21:44:41 +0800</pubDate><guid>http://lestua.eu.org/notes/2022/08/29/223643/</guid><description>[[树的定义与基本术语]] [[树的性质]] [[二叉树的定义与基本术语]] [[二叉树的性质]] [[二叉树的存储结构]] [[二叉树的遍历]] [[</description></item><item><title>静态链表</title><link>http://lestua.eu.org/notes/2022/08/29/223700/</link><pubDate>Sat, 30 Jul 2022 20:46:12 +0800</pubDate><guid>http://lestua.eu.org/notes/2022/08/29/223700/</guid><description>定义 数组形式实习的链表 typedef struct Node { int data; int next; } SLinkedList[MaxSize]; // SLinkedList等价于Node[MaxSize] 基本操作 初始化 bool InitSLinkedList(SLinkedList&amp;amp; L) { L[0].next = -1; //-1表示表</description></item><item><title>链表</title><link>http://lestua.eu.org/notes/2022/08/29/223704/</link><pubDate>Sat, 30 Jul 2022 20:46:12 +0800</pubDate><guid>http://lestua.eu.org/notes/2022/08/29/223704/</guid><description>链表 [[单链表]] [[双链表]] [[循环链表]] 有 [[循环链表#循环单链表]] 和 [[循环链表#循环双链表]] [[静态链表]] 较少考察</description></item><item><title>顺序表</title><link>http://lestua.eu.org/notes/2022/08/29/223712/</link><pubDate>Sat, 30 Jul 2022 20:46:12 +0800</pubDate><guid>http://lestua.eu.org/notes/2022/08/29/223712/</guid><description>定义 用顺序存储的方式实现的线性表。 顺序存储。把逻辑上相邻的元素存储在物理位置上也相邻的存储单元中，元素之间的关系由存储单元的邻接关系来体现。</description></item><item><title>线性表</title><link>http://lestua.eu.org/notes/2022/08/29/223718/</link><pubDate>Sat, 30 Jul 2022 20:46:12 +0800</pubDate><guid>http://lestua.eu.org/notes/2022/08/29/223718/</guid><description>定义 线性表是具有相同数据类型的 n 个数据元素的有限序列 基本操作 InitList(&amp;amp;L): 初始化表。构造空表，分配空间 DestroyList(&amp;amp;L): 销毁操作。销毁线性表，释放空间 ListInsert(&amp;amp;L,i,e): 插入操作。在表 L</description></item><item><title>绪论</title><link>http://lestua.eu.org/notes/2022/08/29/223733/</link><pubDate>Sat, 30 Jul 2022 20:46:12 +0800</pubDate><guid>http://lestua.eu.org/notes/2022/08/29/223733/</guid><description>基本概念 数据元素：数据元素是数据的基本单位，通常作为一个整体进行考虑和处理（编程中的对象） 数据项：一个数据元素可由若干数据项组成，数据项是构</description></item><item><title>循环链表</title><link>http://lestua.eu.org/notes/2022/08/29/223723/</link><pubDate>Sat, 30 Jul 2022 20:46:12 +0800</pubDate><guid>http://lestua.eu.org/notes/2022/08/29/223723/</guid><description>循环单链表 定义 同单链表的定义 ![[单链表#定义]] 初始化 bool InitList(LinkedList&amp;amp; L) { L = (LNode*)malloc(sizeof(LNode)); if (L == nullptr) return false; L-&amp;gt;data = 0; L-&amp;gt;next = L; //尾结点的next域指向头指针 return true; } 判空 bool Empty(LinkedList</description></item><item><title>应试看板</title><link>http://lestua.eu.org/notes/2022/08/29/223835/</link><pubDate>Sat, 30 Jul 2022 20:46:12 +0800</pubDate><guid>http://lestua.eu.org/notes/2022/08/29/223835/</guid><description>应试看板 语言环境：cpp [[tips of cpp]] 408 科目占比 [[数据结构]]45 分 选择题题号 1-11，每题 2 分，共 22 分 大题题号 41-42，共 23 分 [[计算机组成原</description></item><item><title>tips of cpp</title><link>http://lestua.eu.org/notes/2022/08/29/223839/</link><pubDate>Sat, 30 Jul 2022 20:46:11 +0800</pubDate><guid>http://lestua.eu.org/notes/2022/08/29/223839/</guid><description>关于指针 //指针可看作一个数字的容器，其中保存的是 相应类型的变量 的地址 LNode *p;//定义一个指针变量p p = (LNode *)malloc(sizeof(L</description></item><item><title>单链表</title><link>http://lestua.eu.org/notes/2022/08/29/223656/</link><pubDate>Sat, 30 Jul 2022 20:46:11 +0800</pubDate><guid>http://lestua.eu.org/notes/2022/08/29/223656/</guid><description>定义 每个结点除了存放数据元素外，还要存储指向下一个节点的指针 typedef struct LNode { int data; LNode* next; } LNode, * LinkedList; // LinkedList表示LNode型指针，等价于LNo</description></item><item><title>队列</title><link>http://lestua.eu.org/notes/2022/08/29/223739/</link><pubDate>Sat, 30 Jul 2022 20:46:11 +0800</pubDate><guid>http://lestua.eu.org/notes/2022/08/29/223739/</guid><description>定义 队列是只允许在一端进行插入，另一端进行删除的 [[线性表]] 特点 先进先出 1 基本操作 InitQueue(&amp;amp;Q): 初始化队列，构造一个空队列 Q DestroyQueue(&amp;amp;Q): 销毁队列。销毁并释放队列</description></item><item><title>队列的应用</title><link>http://lestua.eu.org/notes/2022/08/29/223745/</link><pubDate>Sat, 30 Jul 2022 20:46:11 +0800</pubDate><guid>http://lestua.eu.org/notes/2022/08/29/223745/</guid><description>队列的应用 树的层次遍历 图的广度优先遍历 操作系统中的先来先服务策略：cpu 调度；打印数据缓存区</description></item><item><title>矩阵的压缩存储</title><link>http://lestua.eu.org/notes/2022/08/29/223749/</link><pubDate>Sat, 30 Jul 2022 20:46:11 +0800</pubDate><guid>http://lestua.eu.org/notes/2022/08/29/223749/</guid><description>普通矩阵可用二维数组存储 (直接存储) 某些特殊矩阵可以压缩存储空间 flowchart LR 特殊矩阵===对称矩阵 &amp;amp; 三角矩阵 &amp;amp; 三对角矩阵 &amp;amp; 稀疏矩阵 subgraph one[ ] 对称矩阵 &amp;amp; 三</description></item><item><title>链式队列</title><link>http://lestua.eu.org/notes/2022/08/29/223753/</link><pubDate>Sat, 30 Jul 2022 20:46:11 +0800</pubDate><guid>http://lestua.eu.org/notes/2022/08/29/223753/</guid><description>定义 typedef struct LinkedNode { int data; LinkedNode* next; } LinkedNode; typedef struct LinkedQueue { LinkedNode* front, * rear; } LinkedQueue; 带头结点 初始化 void InitLinkedQueue(LinkedQueue&amp;amp; Q) { Q.front = Q.rear = (LinkedNode*)malloc(sizeof(LinkedNode)); if (nullptr == Q.front || nullptr == Q.rear) return; Q.front-&amp;gt;next = nullptr; } 判空 bool IsEmtpy(LinkedQueue Q) { if (Q.front == Q.rear) return true; return false; } 入队 void EnLinkedQueue(LinkedQueue&amp;amp;</description></item><item><title>链栈</title><link>http://lestua.eu.org/notes/2022/08/29/223758/</link><pubDate>Sat, 30 Jul 2022 20:46:11 +0800</pubDate><guid>http://lestua.eu.org/notes/2022/08/29/223758/</guid><description>定义 与 [[单链表#定义]] 没有本质区别 typedef struct LNode { int data; LNode* next; } LNode, * LinkedStack; 基本操作 注意操作与单链表操作相比，链栈操作都是在栈顶进行 参考 ![[单链表#基本</description></item><item><title>数据结构</title><link>http://lestua.eu.org/notes/2022/08/29/223830/</link><pubDate>Sat, 30 Jul 2022 20:46:11 +0800</pubDate><guid>http://lestua.eu.org/notes/2022/08/29/223830/</guid><description>[[绪论]] [[线性表]] [[栈、队列和数组]] [[串]] [[树与二叉树]] [[图]] [[查找]] [[排序]]</description></item><item><title>双端队列</title><link>http://lestua.eu.org/notes/2022/08/29/223802/</link><pubDate>Sat, 30 Jul 2022 20:46:11 +0800</pubDate><guid>http://lestua.eu.org/notes/2022/08/29/223802/</guid><description>双端队列 双端队列：只允许从两端插入、两端删除的线性表 输入受限的双端队列：只允许从一端插入、两端删除的线性表 输出受限的双端队列：只允许从两端插</description></item><item><title>双链表</title><link>http://lestua.eu.org/notes/2022/08/29/223708/</link><pubDate>Sat, 30 Jul 2022 20:46:11 +0800</pubDate><guid>http://lestua.eu.org/notes/2022/08/29/223708/</guid><description>定义 typedef struct DNode { int data; DNode* prior, * next; } DNode, * DLinkedList; 初始化 bool InitDLinkedList(DLinkedList&amp;amp; L) { L = (DNode*)malloc(sizeof(DNode)); if (L == nullptr) return false; L-&amp;gt;prior = nullptr; L-&amp;gt;next = nullptr; return true; } 判空 bool Empty(DLinkedList&amp;amp; L) { if (L-&amp;gt;next == nullptr) return true; return false; } 插入 bool InsertNextDNode(DNode* p, DNode* s) { if (p == nullptr || s</description></item><item><title>顺序队列</title><link>http://lestua.eu.org/notes/2022/08/29/223806/</link><pubDate>Sat, 30 Jul 2022 20:46:11 +0800</pubDate><guid>http://lestua.eu.org/notes/2022/08/29/223806/</guid><description>定义 typedef struct { int data[MaxSize]; int front, rear; } SeqQueue; 基本操作 初始化 void InitQueue(SeqQueue&amp;amp; Q) { Q.rear = Q.front = 0; } 判空 bool QueueEmpty(SeqQueue Q) { if (Q.front == Q.rear) return true; return false; } 循环队列 判空 浪费一个空间区分队空队满 队满条件： (Q.rear+1)%MaxSize == Q.front</description></item><item><title>顺序栈</title><link>http://lestua.eu.org/notes/2022/08/29/223809/</link><pubDate>Sat, 30 Jul 2022 20:46:11 +0800</pubDate><guid>http://lestua.eu.org/notes/2022/08/29/223809/</guid><description>定义 typedef struct { int data[MaxSize]; int top; } SeqStack; 基本操作 InitStack(&amp;amp;S) : 初始化栈 void InitStack(SeqStack&amp;amp; S) { S.top = -1; } Push(&amp;amp;S,x): 进栈 bool Push(SeqStack&amp;amp; S, int x) { if (S.top == MaxSize - 1) //栈满 return false; S.top += 1; S.data[S.top] = x; return true; } Pop(&amp;amp;S,&amp;amp;x): 出栈 bool Pop(SeqStack&amp;amp; S, int&amp;amp; x) { if (S.top</description></item><item><title>栈</title><link>http://lestua.eu.org/notes/2022/08/29/223813/</link><pubDate>Sat, 30 Jul 2022 20:46:11 +0800</pubDate><guid>http://lestua.eu.org/notes/2022/08/29/223813/</guid><description>定义 栈是只允许在一端进行插入或删除操作的 [[线性表]] 栈与与普通的线性表相比，逻辑结构相同，插入删除操作有区别 n 个不同元素进栈，出栈元素不同</description></item><item><title>栈、队列和数组</title><link>http://lestua.eu.org/notes/2022/08/29/223817/</link><pubDate>Sat, 30 Jul 2022 20:46:11 +0800</pubDate><guid>http://lestua.eu.org/notes/2022/08/29/223817/</guid><description>[[栈]] [[队列]] [[矩阵的压缩存储]]（数组）</description></item><item><title>栈的应用</title><link>http://lestua.eu.org/notes/2022/08/29/223821/</link><pubDate>Sat, 30 Jul 2022 20:46:11 +0800</pubDate><guid>http://lestua.eu.org/notes/2022/08/29/223821/</guid><description>括号匹配 #include &amp;lt;iostream&amp;gt; #define MaxSize 10 typedef struct { char data[MaxSize]; int top; } SqStack; void InitStack(SqStack&amp;amp; s) { s.top = -1; } bool StackEmpty(SqStack&amp;amp; s) { if (s.top == -1) return true; return false; } bool isIn(char&amp;amp; x, char list[], int length) { for (int i = 0; i &amp;lt; length; i++) if (x == *(list + i)) return true; return false; } //括</description></item></channel></rss>