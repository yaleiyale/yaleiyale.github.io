<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>线性表 on 时砂凝几页</title><link>http://lestua.eu.org/%E5%AD%A6%E7%A0%94%E7%AC%94%E8%AE%B0/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E7%BA%BF%E6%80%A7%E8%A1%A8/</link><description>Recent content in 线性表 on 时砂凝几页</description><generator>Hugo -- gohugo.io</generator><language>zh</language><copyright> 2021-{year} yaleiyale</copyright><lastBuildDate>Sat, 30 Jul 2022 20:46:12 +0800</lastBuildDate><atom:link href="http://lestua.eu.org/%E5%AD%A6%E7%A0%94%E7%AC%94%E8%AE%B0/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E7%BA%BF%E6%80%A7%E8%A1%A8/index.xml" rel="self" type="application/rss+xml"/><item><title>静态链表</title><link>http://lestua.eu.org/notes/2022/08/29/223700/</link><pubDate>Sat, 30 Jul 2022 20:46:12 +0800</pubDate><guid>http://lestua.eu.org/notes/2022/08/29/223700/</guid><description>定义 数组形式实习的链表 typedef struct Node { int data; int next; } SLinkedList[MaxSize]; // SLinkedList等价于Node[MaxSize] 基本操作 初始化 bool InitSLinkedList(SLinkedList&amp;amp; L) { L[0].next = -1; //-1表示表</description></item><item><title>链表</title><link>http://lestua.eu.org/notes/2022/08/29/223704/</link><pubDate>Sat, 30 Jul 2022 20:46:12 +0800</pubDate><guid>http://lestua.eu.org/notes/2022/08/29/223704/</guid><description>链表 [[单链表]] [[双链表]] [[循环链表]] 有 [[循环链表#循环单链表]] 和 [[循环链表#循环双链表]] [[静态链表]] 较少考察</description></item><item><title>顺序表</title><link>http://lestua.eu.org/notes/2022/08/29/223712/</link><pubDate>Sat, 30 Jul 2022 20:46:12 +0800</pubDate><guid>http://lestua.eu.org/notes/2022/08/29/223712/</guid><description>定义 用顺序存储的方式实现的线性表。 顺序存储。把逻辑上相邻的元素存储在物理位置上也相邻的存储单元中，元素之间的关系由存储单元的邻接关系来体现。</description></item><item><title>线性表</title><link>http://lestua.eu.org/notes/2022/08/29/223718/</link><pubDate>Sat, 30 Jul 2022 20:46:12 +0800</pubDate><guid>http://lestua.eu.org/notes/2022/08/29/223718/</guid><description>定义 线性表是具有相同数据类型的 n 个数据元素的有限序列 基本操作 InitList(&amp;amp;L): 初始化表。构造空表，分配空间 DestroyList(&amp;amp;L): 销毁操作。销毁线性表，释放空间 ListInsert(&amp;amp;L,i,e): 插入操作。在表 L</description></item><item><title>循环链表</title><link>http://lestua.eu.org/notes/2022/08/29/223723/</link><pubDate>Sat, 30 Jul 2022 20:46:12 +0800</pubDate><guid>http://lestua.eu.org/notes/2022/08/29/223723/</guid><description>循环单链表 定义 同单链表的定义 ![[单链表#定义]] 初始化 bool InitList(LinkedList&amp;amp; L) { L = (LNode*)malloc(sizeof(LNode)); if (L == nullptr) return false; L-&amp;gt;data = 0; L-&amp;gt;next = L; //尾结点的next域指向头指针 return true; } 判空 bool Empty(LinkedList</description></item><item><title>单链表</title><link>http://lestua.eu.org/notes/2022/08/29/223656/</link><pubDate>Sat, 30 Jul 2022 20:46:11 +0800</pubDate><guid>http://lestua.eu.org/notes/2022/08/29/223656/</guid><description>定义 每个结点除了存放数据元素外，还要存储指向下一个节点的指针 typedef struct LNode { int data; LNode* next; } LNode, * LinkedList; // LinkedList表示LNode型指针，等价于LNo</description></item><item><title>双链表</title><link>http://lestua.eu.org/notes/2022/08/29/223708/</link><pubDate>Sat, 30 Jul 2022 20:46:11 +0800</pubDate><guid>http://lestua.eu.org/notes/2022/08/29/223708/</guid><description>定义 typedef struct DNode { int data; DNode* prior, * next; } DNode, * DLinkedList; 初始化 bool InitDLinkedList(DLinkedList&amp;amp; L) { L = (DNode*)malloc(sizeof(DNode)); if (L == nullptr) return false; L-&amp;gt;prior = nullptr; L-&amp;gt;next = nullptr; return true; } 判空 bool Empty(DLinkedList&amp;amp; L) { if (L-&amp;gt;next == nullptr) return true; return false; } 插入 bool InsertNextDNode(DNode* p, DNode* s) { if (p == nullptr || s</description></item></channel></rss>