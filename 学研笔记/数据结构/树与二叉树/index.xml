<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>树与二叉树 on 时砂凝几页</title><link>http://lestua.eu.org/%E5%AD%A6%E7%A0%94%E7%AC%94%E8%AE%B0/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E6%A0%91%E4%B8%8E%E4%BA%8C%E5%8F%89%E6%A0%91/</link><description>Recent content in 树与二叉树 on 时砂凝几页</description><generator>Hugo -- gohugo.io</generator><language>zh</language><copyright> 2021-{year} yaleiyale</copyright><lastBuildDate>Thu, 08 Dec 2022 22:58:42 +0800</lastBuildDate><atom:link href="http://lestua.eu.org/%E5%AD%A6%E7%A0%94%E7%AC%94%E8%AE%B0/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E6%A0%91%E4%B8%8E%E4%BA%8C%E5%8F%89%E6%A0%91/index.xml" rel="self" type="application/rss+xml"/><item><title>线索二叉树的概念</title><link>http://lestua.eu.org/notes/2022/12/09/083308/</link><pubDate>Thu, 08 Dec 2022 22:58:42 +0800</pubDate><guid>http://lestua.eu.org/notes/2022/12/09/083308/</guid><description>遍历二叉树会得到一个序列，除首尾的中间节点都具有一个直接前驱和一个直接后继。 传统二叉树中有闲置指针1。可以利用这些闲置指针来指向前驱后继，方</description></item><item><title>由遍历序列构造二叉树</title><link>http://lestua.eu.org/notes/2022/12/09/083346/</link><pubDate>Thu, 08 Dec 2022 22:58:09 +0800</pubDate><guid>http://lestua.eu.org/notes/2022/12/09/083346/</guid><description>中序遍历序列结合其他的遍历序列可以唯一的确定一个二叉树。 以先序、中序序列推导为例： 先序序列中第一个节点为根结点。其后为左子树连接右子树的序列</description></item><item><title>线索二叉树</title><link>http://lestua.eu.org/notes/2022/12/09/083332/</link><pubDate>Thu, 08 Dec 2022 22:54:32 +0800</pubDate><guid>http://lestua.eu.org/notes/2022/12/09/083332/</guid><description/></item><item><title>二叉树的遍历</title><link>http://lestua.eu.org/notes/2022/10/14/213638/</link><pubDate>Fri, 14 Oct 2022 21:36:08 +0800</pubDate><guid>http://lestua.eu.org/notes/2022/10/14/213638/</guid><description>先序遍历 先序遍历（PreOrder）的操作过程如下。 若二叉树为空，则什么也不做;否则， 访问根结点; 先序遍历左子树; 先序遍历右子树。 void PreOrder(BiTree T) { if</description></item><item><title>二叉树的存储结构</title><link>http://lestua.eu.org/notes/2022/10/10/084357/</link><pubDate>Mon, 10 Oct 2022 08:43:53 +0800</pubDate><guid>http://lestua.eu.org/notes/2022/10/10/084357/</guid><description>顺序存储 struct TreeNode { int value; bool isEmpty; }; // 定义一个长度为MAXSIZE的数组t,按照从上至下、从左至右的顺序依次存储完全二叉树中的各个结点 TreeNode t[MAXSIZE]; 初始化时所有结</description></item><item><title>二叉树的性质</title><link>http://lestua.eu.org/notes/2022/10/08/223628/</link><pubDate>Sat, 08 Oct 2022 22:41:53 +0800</pubDate><guid>http://lestua.eu.org/notes/2022/10/08/223628/</guid><description>设非空二叉树中度为0、1和2的结点个数分别为$n_0$、$n_1$和$n_2$,则$n_0$=$n_2$+1 (叶子结点比二分支结点多一个)1</description></item><item><title>二叉树的定义与基本术语</title><link>http://lestua.eu.org/notes/2022/10/08/223623/</link><pubDate>Sat, 08 Oct 2022 22:15:07 +0800</pubDate><guid>http://lestua.eu.org/notes/2022/10/08/223623/</guid><description>基础概念 二叉树是n(n≥0)个结点的有限集合： 或者为空二叉树，即n=0。 或者由一个根结点和两个互不相交的被称为根的左子树和右子树组成。左子树</description></item><item><title>树的性质</title><link>http://lestua.eu.org/notes/2022/10/08/223637/</link><pubDate>Sat, 08 Oct 2022 21:30:23 +0800</pubDate><guid>http://lestua.eu.org/notes/2022/10/08/223637/</guid><description>总结点数 = 总度数 + 11 树的度 VS m叉树 树的度：各结点的度的最大值 m叉树：每个结点最多只能有m个孩子的树 度为m的树 m叉树 任意结点的度≤m(最多m个</description></item><item><title>树的定义与基本术语</title><link>http://lestua.eu.org/notes/2022/10/08/223632/</link><pubDate>Sat, 08 Oct 2022 21:25:10 +0800</pubDate><guid>http://lestua.eu.org/notes/2022/10/08/223632/</guid><description>概念 ![[树与二叉树 2022-10-06 14.36.30.excalidraw]] 树是n(n≥0)个结点的有限集合，n=0时，称为空树，这是一种特殊情况。非空树的特性： 有且仅有一个根结点 没有后继的结</description></item><item><title>树与二叉树</title><link>http://lestua.eu.org/notes/2022/08/29/223643/</link><pubDate>Wed, 03 Aug 2022 21:44:41 +0800</pubDate><guid>http://lestua.eu.org/notes/2022/08/29/223643/</guid><description>[[树的定义与基本术语]] [[树的性质]] [[二叉树的定义与基本术语]] [[二叉树的性质]] [[二叉树的存储结构]] [[二叉树的遍历]] [[</description></item></channel></rss>