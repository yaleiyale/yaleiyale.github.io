<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>栈、队列和数组 on 时砂凝几页</title><link>http://lestua.eu.org/%E5%AD%A6%E7%A0%94%E7%AC%94%E8%AE%B0/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E6%A0%88%E9%98%9F%E5%88%97%E5%92%8C%E6%95%B0%E7%BB%84/</link><description>Recent content in 栈、队列和数组 on 时砂凝几页</description><generator>Hugo -- gohugo.io</generator><language>zh</language><copyright> 2021-{year} yaleiyale</copyright><lastBuildDate>Sat, 30 Jul 2022 20:46:11 +0800</lastBuildDate><atom:link href="http://lestua.eu.org/%E5%AD%A6%E7%A0%94%E7%AC%94%E8%AE%B0/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E6%A0%88%E9%98%9F%E5%88%97%E5%92%8C%E6%95%B0%E7%BB%84/index.xml" rel="self" type="application/rss+xml"/><item><title>队列</title><link>http://lestua.eu.org/notes/2022/08/29/223739/</link><pubDate>Sat, 30 Jul 2022 20:46:11 +0800</pubDate><guid>http://lestua.eu.org/notes/2022/08/29/223739/</guid><description>定义 队列是只允许在一端进行插入，另一端进行删除的 [[线性表]] 特点 先进先出 1 基本操作 InitQueue(&amp;amp;Q): 初始化队列，构造一个空队列 Q DestroyQueue(&amp;amp;Q): 销毁队列。销毁并释放队列</description></item><item><title>队列的应用</title><link>http://lestua.eu.org/notes/2022/08/29/223745/</link><pubDate>Sat, 30 Jul 2022 20:46:11 +0800</pubDate><guid>http://lestua.eu.org/notes/2022/08/29/223745/</guid><description>队列的应用 树的层次遍历 图的广度优先遍历 操作系统中的先来先服务策略：cpu 调度；打印数据缓存区</description></item><item><title>矩阵的压缩存储</title><link>http://lestua.eu.org/notes/2022/08/29/223749/</link><pubDate>Sat, 30 Jul 2022 20:46:11 +0800</pubDate><guid>http://lestua.eu.org/notes/2022/08/29/223749/</guid><description>普通矩阵可用二维数组存储 (直接存储) 某些特殊矩阵可以压缩存储空间 flowchart LR 特殊矩阵===对称矩阵 &amp;amp; 三角矩阵 &amp;amp; 三对角矩阵 &amp;amp; 稀疏矩阵 subgraph one[ ] 对称矩阵 &amp;amp; 三</description></item><item><title>链式队列</title><link>http://lestua.eu.org/notes/2022/08/29/223753/</link><pubDate>Sat, 30 Jul 2022 20:46:11 +0800</pubDate><guid>http://lestua.eu.org/notes/2022/08/29/223753/</guid><description>定义 typedef struct LinkedNode { int data; LinkedNode* next; } LinkedNode; typedef struct LinkedQueue { LinkedNode* front, * rear; } LinkedQueue; 带头结点 初始化 void InitLinkedQueue(LinkedQueue&amp;amp; Q) { Q.front = Q.rear = (LinkedNode*)malloc(sizeof(LinkedNode)); if (nullptr == Q.front || nullptr == Q.rear) return; Q.front-&amp;gt;next = nullptr; } 判空 bool IsEmtpy(LinkedQueue Q) { if (Q.front == Q.rear) return true; return false; } 入队 void EnLinkedQueue(LinkedQueue&amp;amp;</description></item><item><title>链栈</title><link>http://lestua.eu.org/notes/2022/08/29/223758/</link><pubDate>Sat, 30 Jul 2022 20:46:11 +0800</pubDate><guid>http://lestua.eu.org/notes/2022/08/29/223758/</guid><description>定义 与 [[单链表#定义]] 没有本质区别 typedef struct LNode { int data; LNode* next; } LNode, * LinkedStack; 基本操作 注意操作与单链表操作相比，链栈操作都是在栈顶进行 参考 ![[单链表#基本</description></item><item><title>双端队列</title><link>http://lestua.eu.org/notes/2022/08/29/223802/</link><pubDate>Sat, 30 Jul 2022 20:46:11 +0800</pubDate><guid>http://lestua.eu.org/notes/2022/08/29/223802/</guid><description>双端队列 双端队列：只允许从两端插入、两端删除的线性表 输入受限的双端队列：只允许从一端插入、两端删除的线性表 输出受限的双端队列：只允许从两端插</description></item><item><title>顺序队列</title><link>http://lestua.eu.org/notes/2022/08/29/223806/</link><pubDate>Sat, 30 Jul 2022 20:46:11 +0800</pubDate><guid>http://lestua.eu.org/notes/2022/08/29/223806/</guid><description>定义 typedef struct { int data[MaxSize]; int front, rear; } SeqQueue; 基本操作 初始化 void InitQueue(SeqQueue&amp;amp; Q) { Q.rear = Q.front = 0; } 判空 bool QueueEmpty(SeqQueue Q) { if (Q.front == Q.rear) return true; return false; } 循环队列 判空 浪费一个空间区分队空队满 队满条件： (Q.rear+1)%MaxSize == Q.front</description></item><item><title>顺序栈</title><link>http://lestua.eu.org/notes/2022/08/29/223809/</link><pubDate>Sat, 30 Jul 2022 20:46:11 +0800</pubDate><guid>http://lestua.eu.org/notes/2022/08/29/223809/</guid><description>定义 typedef struct { int data[MaxSize]; int top; } SeqStack; 基本操作 InitStack(&amp;amp;S) : 初始化栈 void InitStack(SeqStack&amp;amp; S) { S.top = -1; } Push(&amp;amp;S,x): 进栈 bool Push(SeqStack&amp;amp; S, int x) { if (S.top == MaxSize - 1) //栈满 return false; S.top += 1; S.data[S.top] = x; return true; } Pop(&amp;amp;S,&amp;amp;x): 出栈 bool Pop(SeqStack&amp;amp; S, int&amp;amp; x) { if (S.top</description></item><item><title>栈</title><link>http://lestua.eu.org/notes/2022/08/29/223813/</link><pubDate>Sat, 30 Jul 2022 20:46:11 +0800</pubDate><guid>http://lestua.eu.org/notes/2022/08/29/223813/</guid><description>定义 栈是只允许在一端进行插入或删除操作的 [[线性表]] 栈与与普通的线性表相比，逻辑结构相同，插入删除操作有区别 n 个不同元素进栈，出栈元素不同</description></item><item><title>栈、队列和数组</title><link>http://lestua.eu.org/notes/2022/08/29/223817/</link><pubDate>Sat, 30 Jul 2022 20:46:11 +0800</pubDate><guid>http://lestua.eu.org/notes/2022/08/29/223817/</guid><description>[[栈]] [[队列]] [[矩阵的压缩存储]]（数组）</description></item><item><title>栈的应用</title><link>http://lestua.eu.org/notes/2022/08/29/223821/</link><pubDate>Sat, 30 Jul 2022 20:46:11 +0800</pubDate><guid>http://lestua.eu.org/notes/2022/08/29/223821/</guid><description>括号匹配 #include &amp;lt;iostream&amp;gt; #define MaxSize 10 typedef struct { char data[MaxSize]; int top; } SqStack; void InitStack(SqStack&amp;amp; s) { s.top = -1; } bool StackEmpty(SqStack&amp;amp; s) { if (s.top == -1) return true; return false; } bool isIn(char&amp;amp; x, char list[], int length) { for (int i = 0; i &amp;lt; length; i++) if (x == *(list + i)) return true; return false; } //括</description></item></channel></rss>